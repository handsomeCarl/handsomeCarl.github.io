<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[音频格式转化 m4a 转 wav]]></title>
    <url>%2F2019%2F04%2F28%2Fm4a-wav%2F</url>
    <content type="text"><![CDATA[还是因为音频合成的原因，合成的音频是m4a 格式，上传到七牛后，形成的链接，浏览器可以播放。但是手机不行，m4a 是偏视频格式，用原有的avplayer 方法不能播放，所以需要进行转化后上传播放。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116-(void)convetM4aToWav:(NSURL *)originalUrldestUrl:(NSString *)destUrlStrcompleted:(void (^)(NSError *error)) completed &#123;NSLog(@&quot;\n\n\nM4A-WAV\n\n\n&quot;);if ([[NSFileManager defaultManager] fileExistsAtPath:destUrlStr]) &#123;[[NSFileManager defaultManager] removeItemAtPath:destUrlStr error:nil];&#125;NSURL *destUrl = [NSURL fileURLWithPath:destUrlStr];AVURLAsset *songAsset = [AVURLAsset URLAssetWithURL:originalUrl options:nil];//读取原始文件信息NSError *error = nil;AVAssetReader *assetReader = [AVAssetReader assetReaderWithAsset:songAsset error:&amp;error];if (error) &#123;NSLog (@&quot;error: %@&quot;, error);completed(error);return;&#125;AVAssetReaderOutput *assetReaderOutput = [AVAssetReaderAudioMixOutputassetReaderAudioMixOutputWithAudioTracks:songAsset.tracksaudioSettings: nil];if (![assetReader canAddOutput:assetReaderOutput]) &#123;NSLog (@&quot;can&apos;t add reader output... die!&quot;);completed(error);return;&#125;[assetReader addOutput:assetReaderOutput];AVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:destUrlfileType:AVFileTypeCoreAudioFormaterror:&amp;error];if (error) &#123;NSLog (@&quot;error: %@&quot;, error);completed(error);return;&#125;AudioChannelLayout channelLayout;memset(&amp;channelLayout, 0, sizeof(AudioChannelLayout));channelLayout.mChannelLayoutTag = kAudioChannelLayoutTag_Stereo;NSDictionary *outputSettings = [NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithInt:kAudioFormatLinearPCM], AVFormatIDKey,[NSNumber numberWithFloat:8000], AVSampleRateKey,[NSNumber numberWithInt:2], AVNumberOfChannelsKey,[NSNumber numberWithInt:16], AVLinearPCMBitDepthKey,[NSNumber numberWithBool:NO], AVLinearPCMIsNonInterleaved,[NSNumber numberWithBool:NO],AVLinearPCMIsFloatKey,[NSNumber numberWithBool:NO], AVLinearPCMIsBigEndianKey,nil];AVAssetWriterInput *assetWriterInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeAudiooutputSettings:outputSettings];if ([assetWriter canAddInput:assetWriterInput]) &#123;[assetWriter addInput:assetWriterInput];&#125; else &#123;NSLog (@&quot;can&apos;t add asset writer input... die!&quot;);completed(error);return;&#125;assetWriterInput.expectsMediaDataInRealTime = NO;[assetWriter startWriting];[assetReader startReading];AVAssetTrack *soundTrack = [songAsset.tracks objectAtIndex:0];CMTime startTime = CMTimeMake (0, soundTrack.naturalTimeScale);[assetWriter startSessionAtSourceTime:startTime];__block UInt64 convertedByteCount = 0;dispatch_queue_t mediaInputQueue = dispatch_queue_create(&quot;mediaInputQueue&quot;, NULL);[assetWriterInput requestMediaDataWhenReadyOnQueue:mediaInputQueueusingBlock: ^&#123;while (assetWriterInput.readyForMoreMediaData) &#123;CMSampleBufferRef nextBuffer = [assetReaderOutput copyNextSampleBuffer];if (nextBuffer) &#123;// append buffer[assetWriterInput appendSampleBuffer: nextBuffer];// NSLog (@&quot;appended a buffer (%zu bytes)&quot;,// CMSampleBufferGetTotalSampleSize (nextBuffer));convertedByteCount += CMSampleBufferGetTotalSampleSize (nextBuffer);&#125; else &#123;[assetWriterInput markAsFinished];[assetWriter finishWritingWithCompletionHandler:^&#123;&#125;];[assetReader cancelReading];NSDictionary *outputFileAttributes = [[NSFileManager defaultManager]attributesOfItemAtPath:[destUrl path]error:nil];NSLog (@&quot;FlyElephant %lld&quot;,[outputFileAttributes fileSize]);break;&#125;&#125;NSLog(@&quot;转换结束&quot;);// 删除临时temprecordAudio.m4a文件NSError *removeError = nil;if ([[NSFileManager defaultManager] fileExistsAtPath:[originalUrl path]]) &#123;BOOL success = [[NSFileManager defaultManager] removeItemAtPath:[originalUrl path] error:&amp;removeError];if (!success) &#123;NSLog(@&quot;删除临时temprecordAudio.m4a文件失败:%@&quot;,removeError);completed(removeError);&#125;else&#123;NSLog(@&quot;删除临时temprecordAudio.m4a文件:%@成功&quot;,originalUrl);completed(removeError);&#125;&#125;else &#123;NSLog(@&quot;文件不存在&quot;);&#125;&#125;];&#125; 文档目录相关代码如下：12345678910111213141516171819202122232425- (NSString *)documentPath&#123;NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;return documentPath;&#125;- (NSString *)audioCacheFolder&#123;NSString *audioFolder = [[self documentPath] stringByAppendingPathComponent:AUDIOCACHE];if (![FILEMANAGER fileExistsAtPath:audioFolder]) &#123;NSError *error = nil;[FILEMANAGER createDirectoryAtPath:audioFolder withIntermediateDirectories:YES attributes:nil error:&amp;error];if (error) &#123;NSLog(@&quot;音频文件夹创建失败----%@&quot;, error);&#125;&#125;return audioFolder;&#125;//用url作为文件名- (NSString *)audioFilePath:(NSString *)audioURL&#123;NSString *fileName = [audioURL stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;-&quot;];return [[self audioCacheFolder] stringByAppendingPathComponent:fileName];&#125;]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过lame 进行音频格式转化]]></title>
    <url>%2F2019%2F04%2F08%2Flame%E8%BD%AC%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景 因为上一篇音频合成中遇到了一个问题，合成工具不支持wav音频格式转化，而且录音所得的wav格式 是无损的格式，标准的wav采样率为44100Hz，也是CD标准格式；mp3属于有损压缩文件，不过体积小，便于保存。lame 下载下来不能直接用 依赖的东西 ：lame库下载地址lame 静态库打包工具地址 操作步骤： 把下载的lame和build-lame.sh放在一个文件夹下 注意 # build-lame.sh 中 #directories SOURCE=”lame”这里lame是来源文件名 在创建的目录下执行 bulid 脚本 1sudo ./build-lame.sh 下面 fat-lame 中就是我们想要的东西，将.a 文件和.h文件放入项目即可 wav 转map3 相关代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#define AUDIOCACHE @&quot;音频存放目录&quot;文件管理#define FILEMANAGER [NSFileManager defaultManager]- (NSString *)documentPath&#123;NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;return documentPath;&#125;- (NSString *)audioCacheFolder&#123;NSString *audioFolder = [[self documentPath] stringByAppendingPathComponent:AUDIOCACHE];if (![FILEMANAGER fileExistsAtPath:audioFolder]) &#123;NSError *error = nil;[FILEMANAGER createDirectoryAtPath:audioFolder withIntermediateDirectories:YES attributes:nil error:&amp;error];if (error) &#123;NSLog(@&quot;音频文件夹创建失败----%@&quot;, error);&#125;&#125;return audioFolder;&#125;//用url作为文件名- (NSString *)audioFilePath:(NSString *)audioURL&#123;NSString *fileName = [audioURL stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;-&quot;];return [[self audioCacheFolder] stringByAppendingPathComponent:fileName];&#125;//转化方法- (NSString *)audioPCMtoMP3:(NSString *)wavPath &#123;NSString *cafFilePath = wavPath;NSString *mp3FilePath = [self audioFilePath];if([FILEMANAGER removeItemAtPath:mp3FilePath error:nil])&#123; NSLog(@&quot;删除原MP3文件&quot;);&#125;@try&#123;int read, write;FILE *pcm = fopen([cafFilePath cStringUsingEncoding:1], &quot;rb&quot;);//source 被转换的音频文件位置fseek(pcm, 4*1024, SEEK_CUR);//skip file headerFILE *mp3 = fopen([mp3FilePath cStringUsingEncoding:1], &quot;wb&quot;);//output 输出生成的Mp3文件位置const int PCM_SIZE = 8192;const int MP3_SIZE = 8192;short int pcm_buffer[PCM_SIZE*2];unsigned char mp3_buffer[MP3_SIZE];lame_t lame = lame_init();// lame_set_in_samplerate(lame, 22050.0);lame_set_in_samplerate(lame, 4000.0);lame_set_VBR(lame, vbr_default); lame_init_params(lame);do &#123;read = fread(pcm_buffer, 2*sizeof(short int), PCM_SIZE, pcm);if (read == 0) write = lame_encode_flush(lame, mp3_buffer, MP3_SIZE);else write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, MP3_SIZE);fwrite(mp3_buffer, write, 1, mp3);&#125;while (read != 0);lame_close(lame);fclose(mp3);fclose(pcm);&#125; @catch (NSException *exception) &#123;NSLog(@&quot;%@&quot;,[exception description]);return @&quot;&quot;;&#125; @finally &#123;return mp3FilePath;&#125;&#125; refer ： https://www.jianshu.com/p/864a9fbaa79e]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gitlab+fastlane进行自动化构建]]></title>
    <url>%2F2019%2F03%2F29%2Fmy-hello-world%2F</url>
    <content type="text"><![CDATA[持续集成优点：1、缩减开发周期，快速迭代版本 2、提供分发效率，测试人员以及相关人员无需等待开发人员打包 3、减少重复操作，高效打包，减轻开发人员工作量。 4 . 将代码推送到新的分支，CI 服务器就会为您运行测试。 如果 job 都是绿色 的，你的代码是 OK 的。 5 . 如果给定分支中的所有测试都是绿色的，则可以让 CI 服务器自动将代码部署到生产环境中。 这就是所谓的连续部署(Continuous Deployment) 。 6 . 减少 code review 时间 搭建方法运行环境要求 gitlab gitlabrunner fastlane 钉钉机器人 搭建步骤1. 安装 gitlab runner Install GitLab Runner on macOS（我的是 mac 环境所以选择的 Install GitLab Runner on macOS）*1.Download the binary for your system 1sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64 2.Give it permissions to execute: 1sudo chmod +x /usr/local/bin/gitlab-runner 2. 注册 gitlab runner To register a Runner under macOS:*1. Run the following command: 1gitlab-runner register 2Enter your GitLab instance URL: （你 gitlab 的地址） 12Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )https://gitlab.com Enter the token you obtained to register the Runner:（CI/CD 中项目的 token） 12Please enter the gitlab-ci token for this runnerxxx Enter a description for the Runner, you can change this later in GitLab’s UI: 12Please enter the gitlab-ci description for this runner[hostame] my-runner Enter the tags associated with the Runner, you can change this later in GitLab’s UI: 12Please enter the gitlab-ci tags for this runner (comma separated):my-tag,another-tag 6 Enter the Runner executor: 12Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shel 3. 编写 yml 文件配置项目的 yml 文件进行相应的 job 操作校验 yml 文件是否正确本地调试 yml 文件安装 jq 这个输出报告的时候用 1brew install jq 下面是我的 yml 文件仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//构建阶段stages:- build- buildAndUpload- failure//构建前配置before_script:- export LANG=en_US.UTF-8- export FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT=120# build for branch test build and upload to pgyer.job1://注册 runner tag名 可以多个tags:- wangweitagsstage: buildAndUploadscript:# - sh ./Shell/dingtalk.sh &quot;新版本&quot; &quot;# 构建新版本（justademo）&quot;- echo $(pwd)- echo &quot;build job1&quot;- pod install- git reset --hard// fastlane 自动化构建- fastlane dev// 输出相关的git commit等相关信息- export pgyerDes=`git log -10 --oneline | cut -d &quot; &quot; -f2- | grep -E &apos;^\[.*|.*finish$&apos;`- echo $&#123;pgyerDes&#125;- echo $(pwd)- echo $(ls)- export result=$(curl -# -F &quot;file=@../product/LZMDYW.ipa&quot; -F &quot;_api_key=2c34b4faa9e0559667c828f415f7ebee&quot; -F &quot;userKey=1ce44e894fbe779bbf23e75d12c482d8&quot; -F &quot;buildUpdateDescription=$&#123;pgyerDes&#125;&quot; https://www.pgyer.com/apiv2/app/upload)- echo $&#123;result&#125; | jq- export buildKey=`echo $&#123;result&#125; | jq &apos;. | .data.buildKey&apos; | awk -F &apos;&quot;&apos; &apos;&#123;print $2&#125;&apos;`buildQRCodeURL=`echo $&#123;result&#125; | jq &apos;. | .data.buildQRCodeURL&apos; | awk -F &apos;&quot;&apos; &apos;&#123;print $2&#125;&apos;`buildVersion=`echo $&#123;result&#125; | jq &apos;. | .data.buildVersion+&quot;(&quot;+.data.buildBuildVersion+&quot;)&quot;&apos; | awk -F &apos;&quot;&apos; &apos;&#123;print $2&#125;&apos;`buildUpdated=`echo $&#123;result&#125; | jq &apos;. | .data.buildUpdated&apos; | awk -F &apos;&quot;&apos; &apos;&#123;print $2&#125;&apos;`change_log=`git log -20 --oneline | cut -d &quot; &quot; -f2- | grep -E &apos;^\[.*|.*finish$&apos; | awk &apos;&#123;&#123;printf&quot;##### %s; \n&quot;,$0&#125;&#125;&apos;`- export text=&quot;### 版本&quot;$&#123;buildVersion&#125;&quot; \n &gt; 更新记录 \n\n &gt; &quot;$&#123;change_log&#125;&quot; \n\n &gt; ![screenshot](&quot;$&#123;buildQRCodeURL&#125;&quot;)\n##### [下载链接](https://www.pgyer.com/&quot;$&#123;buildKey&#125;&quot;)\n\n###### 上传日期:&quot;$&#123;buildUpdated&#125;&quot;&quot;//钉钉脚本- sh ./Shell/dingtalk.sh &quot;新版本&quot; &quot;$text&quot;only:- /^test.*$/# build for branch only build.job2:tags:- wangweitagsstage: buildscript:# - sh ./Shell/dingtalk.sh &quot;新版本&quot; &quot;# 构建新版本（justademo）&quot;- echo $(pwd)- echo &quot;build job2&quot;- pod install- git reset --hard//fastlen 构建- fastlane CI_devonly:- dev- master# notify when a build has erroredbuild_failure_job:tags:- wangweitagsstage: failurescript:// 丁丁脚本- sh ../Shell/dingtalk.sh &quot;新版本&quot; &quot;# 构建失败（LZMDYW）&quot;when: on_failure 4. fastlane 构建https://docs.fastlane.tools/getting-started/ios/setup/ （1）安装 xcode 命令行工具 xcode-select –install，如果没有安装，会弹出对话框，点击安装。如果提示 xcode-select: error: command line tools are already installed, use “Software Update” to install updates 表示已经安装 #####（2） 安装 Fastlanesudo gem install fastlane -NV 或是 brew cask install fastlane 我这里使用 gem 安装的安装完了执行 fastlane –version，确认下是否安装完成和当前使用的版本号。 （3）初始化 Fastlanecd 到你的项目目录执行fastlane init （4）打包到蒲公英1fastlane add_plugin pgyer 自己的 fastlane 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051default_platform(:ios)platform :ios dodesc &quot;Description of what the lane does&quot;lane :dev dosigh(force: true,username: &quot;开发者账号&quot;,app_identifier: &quot;bundleid&quot;,output_path: &apos;.ipa包输出路径&apos;,adhoc: true （是否adhoc）)build_app(workspace: &quot;XXXX.xcworkspace&quot;,configuration: &quot;Debug&quot;, （scheme配置）scheme: &quot;XXXX&quot;,export_method: &quot;ad-hoc&quot;,output_directory:&quot;.ipa包输出路径&quot;,include_bitcode:true,)// 打包到蒲公英pgyer(api_key: &quot;&quot;,user_key: &quot;&quot;,update_description: &quot;scheme is dev, update by fastlane&quot;)endlane :CI_dev dosigh(force: true,username: &quot;开发者账号&quot;,app_identifier: &quot;bundleid&quot;,output_path: &apos;.ipa包输出路径&apos;,adhoc: true （是否adhoc）)build_app(workspace: &quot;XXXX.xcworkspace&quot;,configuration: &quot;Debug&quot;, （scheme配置）scheme: &quot;XXXX&quot;,export_method: &quot;ad-hoc&quot;,output_directory:&quot;.ipa包输出路径&quot;,include_bitcode:true,)endend 5.钉钉通知12345678910111213#! bin/bashecho $2curl &apos; 放自己注册的钉钉机器人的token&apos; \-H &quot;Content-Type:application/json&quot; \-d &quot;&#123; \markdown:&#123; \title:&apos;$1&apos;, \text:&apos;$2&apos; \&#125;, \msgtype:&apos;markdown&apos; \&#125;&quot; 6 fastlane 构建注意事项（三天两头的加测试机，手动更新配置文件更新实在是太麻烦了，要不老是提示双重认证）refer：https://blog.csdn.net/weixin_34293911/article/details/87011860 fastlane iOS 双重认证 更新配置文件这个时候就用到这个，他可以自动管理配置开发者等信息https://github.com/fastlane/fastlane/tree/master/spaceship 访问 AppleId 管理站 找到 安全 - App 专用密码，生成一个专用密码 配置环境变量 vim ~/.bash_profile export 1FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD=YOUR_PSD 执行 fastlane spaceauth -u abcd@qq.com 按提示获取 session 信息。 复制 session 信息（很长一大段） 配置环境变量 vim ~/.bash_profile 1export FASTLANE_SESSION=&apos;YOUR SESSION&apos;]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>自动化构建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS音频合并的多种方式]]></title>
    <url>%2F2019%2F03%2F28%2Faduiomix%2F</url>
    <content type="text"><![CDATA[最近在做音频合并这块需求，然后遇见了几种形式，这里做一个总结。 第一种 可网络可本地 ，可调整音量，范围等 定制化还比较高 1.基本类介绍refer：https://docs.microsoft.com/en-us/dotnet/api/avfoundation.avcomposition?view=xamarin-ios-sdk-12 AVAsset 媒体信息 AVURLAsset 根据URL路径创建的媒体信息 AVAssetTrack 资源轨道，包括音频轨道和视频轨道 AVMutableAudioMixInputParameters音频操作参数 AVMutableComposition 继承自AVComposition，用于从现有Asset创建新合成的可变对象。包含多个轨道的媒体信息，可以添加、删除轨道 AVAssetExportSession 导出 具体实现如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#pragma mark - 音频与音频的合并+ (void)mixOriginalAudio:(NSURL *)originalAudioPathoriginalAudioVolume:(float)originalAudioVolumebgAudioPath:(NSURL *)bgAudioPathbgAudioVolume:(float)bgAudioVolumeoutPutFileName:(NSString *)fileNamecompletionBlock:(CompletionBlock)completionBlock&#123;if (originalAudioPath == nil) &#123;return;&#125;if (bgAudioPath == nil) &#123;return;&#125;if (originalAudioVolume &gt; 1.0) &#123;originalAudioVolume = 1.0f;&#125;if (originalAudioVolume &lt; 0) &#123;originalAudioVolume = 0.0f;&#125;if (bgAudioVolume &gt; 1.0) &#123;bgAudioVolume = 1.0f;&#125;if (bgAudioVolume &lt; 0) &#123;bgAudioVolume = 0.0f;&#125;dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;AVURLAsset *originalAudioAsset = [AVURLAsset assetWithURL:originalAudioPath];AVURLAsset *bgAudioAsset = [AVURLAsset assetWithURL:bgAudioPath];AVMutableComposition *compostion = [AVMutableComposition composition];AVMutableCompositionTrack *originalAudio = [compostion addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0];[originalAudio insertTimeRange:CMTimeRangeMake(kCMTimeZero, originalAudioAsset.duration) ofTrack:[originalAudioAsset tracksWithMediaType:AVMediaTypeAudio].firstObject atTime:kCMTimeZero error:nil];AVMutableCompositionTrack *bgAudio = [compostion addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0];[bgAudio insertTimeRange:CMTimeRangeMake(kCMTimeZero, originalAudioAsset.duration) ofTrack:[bgAudioAsset tracksWithMediaType:AVMediaTypeAudio].firstObject atTime:kCMTimeZero error:nil];//播放速率会受影响NSUInteger originalAudioAssetTotalSeconds = CMTimeGetSeconds(originalAudioAsset.duration);NSUInteger bgAudioAssetTotalSeconds = CMTimeGetSeconds(bgAudioAsset.duration);if (originalAudioAssetTotalSeconds&gt;bgAudioAssetTotalSeconds) &#123;[bgAudio scaleTimeRange:CMTimeRangeMake(kCMTimeZero, bgAudioAsset.duration) toDuration:originalAudioAsset.duration];&#125;/** 得到对应轨道中的音频声音信息，并更改 */AVMutableAudioMixInputParameters *originalAudioParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:originalAudio];[originalAudioParameters setVolume:originalAudioVolume atTime:kCMTimeZero];AVMutableAudioMixInputParameters *bgAudioParameters = [AVMutableAudioMixInputParameters audioMixInputParametersWithTrack:bgAudio];[bgAudioParameters setVolume:bgAudioVolume atTime:kCMTimeZero];/** 赋给对应的类 */AVMutableAudioMix *audioMix = [AVMutableAudioMix audioMix];audioMix.inputParameters = @[ originalAudioParameters, bgAudioParameters ];AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:compostion presetName:AVAssetExportPresetAppleM4A];/** 设置输出路径 */NSURL *outputPath = [self exporterAudioPathWithFileName:fileName];session.audioMix = audioMix;session.outputURL = outputPath;session.outputFileType = AVFileTypeAppleM4A;session.shouldOptimizeForNetworkUse = YES;[session exportAsynchronouslyWithCompletionHandler:^&#123;dispatch_async(dispatch_get_main_queue(), ^&#123;switch ([session status]) &#123;case AVAssetExportSessionStatusFailed: &#123;NSLog(@&quot;合成失败：%@&quot;, [[session error] description]);completionBlock(NO, outputPath);&#125; break;case AVAssetExportSessionStatusCancelled: &#123;completionBlock(NO, outputPath);&#125; break;case AVAssetExportSessionStatusCompleted: &#123;completionBlock(YES, outputPath);&#125; break;default: &#123;completionBlock(NO, outputPath);&#125; break;&#125;&#125;);&#125;];&#125;);&#125; ⚠️压缩时长 更改给定时间范围内所有轨道的时长。123456- (void)scaleTimeRange:(CMTimeRange)timeRangetoDuration:(CMTime)duration;参数timeRange:要缩放的合成轨道的时间范围。参数duration:新的时长。受缩放操作影响的每个轨道段将以等于其结果时间映射的source.duration/target.duration的速率呈现。 ⚠️设置背景音乐时长和插入时间12[bgAudio insertTimeRange:CMTimeRangeMake(kCMTimeZero, originalAudioAsset.duration) ofTrack:[bgAudioAsset tracksWithMediaType:AVMediaTypeAudio].firstObject atTime:kCMTimeZero error:nil];因为我的需求是加入背景音乐给录音，所以将背景音乐从头插入kCMTimeZero 插入时长为录音的时长 originalAudioAsset.duration ⚠️注意导出格式首先是输出路径,切记切记这里的后缀一定要和上面选择的呼应,比如我写的格式为AVAssetExportPresetAppleM4A那么我的文件后缀就需要为.m4a,如果用.MP3这种的话是无法正确生成出文件的,有可能会出现空文件的存在.一定要注意!!! ⚠️传入网络链接的时候 需要将网络链接下载下来转成本地路径进行传入。refer： https://github.com/Anny-github/AudioPlayerManager 第二种 本地音频合并，可以调整音量https://github.com/daybreak1024/ZLMMixAudio 第三种 可以网络或者本地合并，但是无法定制化，因为用的别人的静态库😢https://github.com/QuintGao/GKDubbingDemo]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>mix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UItouch事件被tableview拦截]]></title>
    <url>%2F2019%2F02%2F20%2Fuitouch%2F</url>
    <content type="text"><![CDATA[最近做项目用到了手写签名的功能，手写签名的view是通过UItouch相关方法画线实现的，因为页面UI是列表形式，手写签名view 需要添加到tableview的footview上，这个时候就出现了问题，手写签名view的touch被tableview拦截了，这个时候再去操作view 签名的时候 是不能成功呢，而且页面会滚动。 下面我记录一下我的处理方式1.一开始我以为像网上的方式，给tableview创建一个子类然后引入touch 方法：refer https://blog.csdn.net/qq_42839789/article/details/81501832但是view的touch 会覆盖tableviewtouch 并不能解决问题。2.这个时候我想到hittest 方法通过事件响应机制，判断触摸的view是不是签名view 如果是让tableview暂时停止滚动，如果不是正常滚动。具体实现如下：123456789101112131415161718192021222324#import &lt;UIKit/UIKit.h&gt;@interface WYTouchTableView : UITableView@end#import &quot;WYTouchTableView.h&quot;#import &quot;HJSignatureView.h&quot;@implementation WYTouchTableView- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;UIView *viewReturn =[super hitTest:point withEvent:event];//在touchView区域if ([viewReturn isKindOfClass:[HJSignatureView class]]) &#123;self.scrollEnabled = NO;return viewReturn;&#125;else&#123;self.scrollEnabled = YES;&#125;//不在touchView区域，正常操作return viewReturn;&#125;@end]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>someBug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建静态私有库]]></title>
    <url>%2F2019%2F01%2F28%2F%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[在上篇文章中介绍了Cocoapods私有库的创建有些时候我们并不希望别人引用咱们的库的时候看见我们的相关实现代码，这个时候就需要将相关代码，打成静态库。第一 .a和.framwork的区别：iOS静态库形式和动态库形式：静态库：.a和.framework动态库：.dylib和.framework.a是一个纯二进制文件，.framework中除了有二进制文件外还有资源文件。.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。.a + .h + sourceFile = .framework第二 我们可以通过两种方式进行静态库的打包，1是手动打包比较麻烦，网上有好多相关教程，这里就不一一介绍了2命令行打包，这个比较简单，一条命令即可1）安装打包插件终端执行以下命令sudo gem install cocoapods-packager2）进入私有库目录 然后将源码导入classes 目录下 然后执行下面的命令pod package demo.podspec –library –force其中–library指定打包成.a文件，如果不带上将会打包成.framework文件。–force是指强制覆盖。这个时候目录下会多出一个文件夹然后将framework文件复制到aesEncrypts/Framework/下面第三 配置相关私有库信息1）将相关framework导入私有库目录下2）配置spec文件 管理.framework跟管理.a类似，同样是生成通用framework。只不过podspec有点不同。.a是s.vendored_libraries，.framework是s.vendored_frameworks。3）.tag标记,并且上传123/// 第一次需要在前面加一个vgit tag &quot;v1.0.0&quot;git push --tags 6.验证.podspec 方式一// 加上–verbose验证失败会显示详细的报错信息pod spec lint aesEncrypts.podspec –verbose方式二pod spec lint7.发布自己的.podspec到cocoapodspod trunk push aesEncrypts.podspec如果有警告用:pod trunk push aesEncrypts.podspec –allow-warnings 注意：注意cocopods 版本 不要用beta 版本进行创建，要不lib 验证可以通过，但是spec 方式验证会出错。pod spec相对于pod lib 会更为精确，pod lib相当于只验证一个本地仓库，pod spec会同时验证本地仓库和远程仓库。 如果spec文件不通过，spec 文件是不能上传到远程仓库]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>.a</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建cocopods私有库]]></title>
    <url>%2F2019%2F01%2F18%2FcocopodKu%2F</url>
    <content type="text"><![CDATA[通常我们项目中都有一些公共的组件需要抽离出来，减少依赖，今天跟大家介绍的就是怎么通过cocopods创建私有库，引入到项目中供大家使用。一 首先要明白两个概念:1.code repository是代码库。2.spec repository是配置仓库，所有的配置按照包名、源地址，相关依赖的存放在这个仓库。这个仓库只用来存放podspec文件，不存放代码。二 创建cocopods仓库相关步骤：1.在本地创建lib仓库pod lib create podsDemoSdk1）相关目录结构如下：2）创建时候相关信息如下： 将本地仓库关联到远端git仓库 我们用的是gitlab 创建的git仓库1）git add . #不但可以[跟单]文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了，注意空格2）git commit -m “注释” #把文件提交到仓库3）git remote add origin 远程仓库地址 #本地关联远程仓库4）git push -u origin master #把本地库的所有内容推送到远程库上（第一次需要加-u，后面就不用加了） 将相关sdk 代码放在 podsDemoSdk/Classes 目录下4.配置相关spec 文件配置相关远程仓库地址和相关内容，按着图中格式配就行了。 验证podspec的有效性，打开终端 cd 到podsDemoSdk的目录中接着运行pod lib lint如果有警告，会导致无法通过，需要添加–allow-warnings如果使用了c函数相关的，需要添加–use-libraries显示pass 字眼 验证通过后，把代码提交到仓库即可5.把代码提交到仓库即可git add -Agit commit -m “add pod files”git remote add origin 远程仓库 //连接远程github项目git tag ‘0.1.0’ //这里的版本号注意要和podspec文件中的版本号统一git push –tags //将本地tag更新到github项目上去git push origin master //将本地项目更新到github项目上去 创建一个spec私有仓库现在GitLab上面创建一个私有仓库，用来存放私有依赖代码库的配置在终端执行命令：pod repo add podsDemoSpecs spec仓库地址 也就是在~/.cocoapods/repo目录下添加了一个以你的私有repo为名的文件夹 现在为止，我们已经在本地得到我们自己的私有仓库 podsDemoSpecs ，这是一个空的仓库 7.关联代码库和配置仓库pod repo push podsDemoSpecs podsDemoSdk.podspec –use-libraries –allow-warnings 至此仓库已经创建完成 三，下面是在项目中的应用，直接在podfile文件中配置相关信息就好，pod install即可 谢谢，如果不足，请指正谢谢!]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合fastlane 组件进行自动化测试]]></title>
    <url>%2F2018%2F12%2F28%2Ffastlane-test%2F</url>
    <content type="text"><![CDATA[1.Xcode创建一个含有Unit Tests的项目1）单元测试target设置info中添加tests，options中勾选Gather coverage框。xcode9.2和xcode9.3位置不太一样，下面的图片是xcode9.3的配置 这个是测覆盖率用的2.安装fastlane1）sudo gem install fastlane -NV或是brew cask install fastlane我这里使用gem安装的2）安装完了执行fastlane –version，确认下是否安装完成和当前使用的版本号。、&gt;3.初始化Fastlane1）cd到你的项目目录执行2）fastlane init初始化成功后会在当前工程目录生成一个fastlane文件夹Appfile主要存放App的apple_id team_id app_identifier等信息Deliverfile中为发布的配置信息，一般情况用不到。Fastfile是我们最应该关注的文件，也是我们的工作文件。4) 添加组件fastlane add_plugin xcpretty_report 用于生成测试报告5）配置Fastfile相关信息`default_platform(:ios) platform :ios do desc “自动化测试” lane :unittest doUI.message(“start xcodebuild”)xcodebuild(test: true,scheme: “quickDemo”,workspace: “quickDemo.xcworkspace”,destination: “platform=iOS Simulator,name=iPhone XR,OS=12.1”,)UI.message(“success xcodebuild”) xcpretty_report(buildlog_path: ‘fastlane’,output_path: ‘fastlane/reports’,use_json_formatter: true) gym(xcpretty_report_html:”tests.html”,)UI.message(“start xcov”)xcov(scheme: “quickDemo”,workspace: “quickDemo.xcworkspace”,html_report: “true”,json_report: “true”,output_directory:”quickDemoesss”)UI.message(“success xcov”) desc “读取覆盖率”file = File.read(File.expand_path(“/Users/edz/Desktop/quickDemo/quickDemoesss/report.json”))if filedata = JSON.parse(file)UI.message(data)UI.message(data[“coverage”])elseUI.error(“Unable to open file!”)returnendend end` 6 执行 fastlane unittest]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode10坑】用xcode10 打包上传到AppStore，iOS9 Crash]]></title>
    <url>%2F2018%2F11%2F28%2Fxcode10%2F</url>
    <content type="text"><![CDATA[用Xcode10 打包上传到AppStore，iOS9系统的机器频繁 Crash; 还是老老实实用Xcode 9.4.1打包吧，坑死了。xcode10.1会解决这个问题。]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>someBug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multiple commands produce '' 日常error记载]]></title>
    <url>%2F2018%2F10%2F28%2Fmuitiple-error%2F</url>
    <content type="text"><![CDATA[下载别人demo 或者日常写项目中会遇到类似如下的bug： 这个时候可以通过如下方式，删除info.plist 然后command+R 允许即可 完美：]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>someBug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 10 打包导出时报错Failed to verify bitcode in]]></title>
    <url>%2F2018%2F09%2F28%2FxcodeBug%2F</url>
    <content type="text"><![CDATA[作为iOS开发者,新的开发工具正式发布时定然要及时更新，但不幸的是有好多坑。这是其中一个比较难遇见的坑，其他的在网上比较好找，就不一一列出了。当打包导出的时候，提示错误如下： Failed to verify bitcode in AipBase.framework/AipBase: error: Cannot extract bundle from /var/folders/n2/2hc63w0d555cdbpqxwmpy84w0000gn/T/XcodeDistPipeline.ujv/Root/Payload/DDGD.app/Frameworks/AipBase.framework/AipBase (i386) 方法一： 这是因为code 新的build System造成的，一个避免延误开发打包的方法展示给大家：进入xcode -file-workSpace settings ： 选择 legacy build System 重新打包导出解决问题。 方法二：为了方便开发者调试，AipBase.framework合并了模拟器和真机架构，上线前，使用lipo工具移除相关架构即可，就可以解决这个问题，这个解决的比较彻底，建议用这个方法： cd lib 使用lipo -info 可以查看包含的架构lipo -info AipBase.framework/AipBase # Architectures in the fat file: AipBase are: i386 x86_64 armv7 armv7s arm64 # 移除x86_64, i386 lipo -remove x86_64 AipBase.framework/AipBase -o AipBase.framework/AipBase lipo -remove i386 AipBase.framework/AipBase -o AipBase.framework/AipBase lipo -remove x86_64 AipOcrSdk.framework/AipOcrSdk -o AipOcrSdk.framework/AipOcrSdk lipo -remove i386 AipOcrSdk.framework/AipOcrSdk -o AipOcrSdk.framework/AipOcrSdk # 再次查看 lipo -info AipBase.framework/AipBase # Architectures in the fat file: AipBase are: armv7 armv7s arm64]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>someBug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
